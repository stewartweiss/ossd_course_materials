<!DOCTYPE html>
<html>
  <head>
    <title>bash</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link href="css/slides.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: center, middle

# CSCI 395.86 Open Source Software Development

<br>

## Working in the Linux Command-Line

.author[
Stewart Weiss <br>
]



.license[
Unless noted otherwise all content is released under a
 [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by/4.0/).
]


---

# Overview

- There are many different Unix operating systems. __Linux__ is one of them.
Other popular forms of Unix include BSD variants such as FreeBSD, proprietary
versions such as IBM's AIX and Oracle's Solaris, and Android.

- Most of what is in these slides is true of all "flavors" of UNIX, but some of
it is only true of Linux.

- There is too much to cover about working in the Unix command-line in a short slide
presentation.

- These slides cover many topics, none in great depth. But they are designed to
cover the most important aspects of working in the _UNIX programming environment_.

- Working in the command-line really means two things:
    - using Unix __commands__ and
    - using the __shell__.

- These slides start with commands and then cover the most common Linux shell,
__bash__.

- You are encouraged to read the many resources on the topics presented here.
The last slide has links to the ones I think are good and concise.

---
# A Bit about Shells

- You need to know a bit about shells before you can type any commands in Unix,
so we begin with the very basics.

- A __shell__ is an interactive command-line interpreter for the operating
system, but it is also  a programming language.

- A __command-line interpreter__ is a program that displays a prompt
(such as '$') and  waits for you to type a command.
When you type the command followed by a _newline_ character, it "executes"
that command and then redisplays the prompt and starts this cycle all over again.

- Example:
   ```bash
     $ whoami
     stewart
   ```
    - `whoami` is an unusual command - it displays your username just in case
you forgot.

- The prompt can be customized in many ways*. On the system in which I have
prepared these slides, whose name is `harpo`, my prompt is
   ```bash
    [stewart@harpo slides]$
   ```

.footnote[
The PS1 shell variable in `bash` controls the first level prompt string.
]


---
# Command Introduction


- Unix commands are the tools that you use to get things done in Unix. You type
their names at the shell prompt, and they do their magic.

- Examples
   ```bash
    $ date
    Thu Mar 28 11:22:45 EDT 2019
    $ echo "Hello world. Code responsibly!"
    Hello world. Code responsibly!
    $ wc  css/slides.css
    167  332 2661 css/slides.css
   ```

    - The `date` command displays the current time and date;
    - `echo` displays the strings that follow it on the command-line;
    - `wc` is short for __w__ord __c__ount; it displays the number of lines,
words, and characters in the file(s) whose names follow it on the command-line.

---

# Files and Directories

- Files reside in a large tree called the __directory hierarchy__.
Each  has  a  __pathname__  describing  the  path  from the root of the tree
(which is called /) to the file.

- A directory is just a special type of file that contains a table with file
names and a way to find the actual files on the system's storage devices.

- There are two special directories: the __home directory__, and the
__current working directory__. The home directory is the one you see when you
login to the Unix system. The current working directory is the one you are
"currently in".

- The home directory has the abbreviation `~` and the current  directory
has the abbreviation  `.` ( a period).

- The `ls` command displays the contents of a directory:
   ```bash
    $ls .
    bash_tutorial.html css  img js
   ```
- As  a convenience, files in the current directory can be named by their last
component. That is why a file like `/home/stewart/notes` can be abbreviated to
`notes` when my current directory is `/home/stewart`.

---
# Types of Commands

- Every Unix __command__ is either an executable file, or a command that is built
into a shell (or sometimes both!)
    - Commands like `ls` and `date` are executable binaries.
    - Commands like `cd` and `bg` are usually __shell built-ins__;
they are implemented within the shell program itself.
    - Commands like `pwd` and `echo` are both shell built-ins and executable files.

- If a command is an executable, the `which` command will display the (absolute)
pathname of that executable:
   ```bash
    $which ls
    /bin/ls
   ```
- The `type` command (which is built-in) displays the type(s) of its arguments:
   ```bash
    $type pwd cal
    pwd is a shell builtin
    cal is /usr/bin/cal
   ```
---
# Getting Help

- Of course you can do browser searches for help; on commands, but it is easier
to use the resources found right on your machine.

- The `man` command is the first thing to try. `man` is short for __man__ual.

- To access the __manual page__ for a command, type `man` followed by the
command name. E.g.,

   ```bash
    $man ls
   ```
brings up the man page (short for manual page) for `ls`.

- There is also the `info` command, which works for those commands that have
`info` pages. Not all pages do. Type
   ```bash
    $info
   ```
to see the starting page for the `info` system, which lists its table of contents.

---
# Categories of Commands

- There are thousands of commands.
Following are categories with the most useful commands in each, in no
particular order.

- File and Directory Processing
    - `ls, more, less, cat, file, view, od, strings, pwd, basename, dirname,`
`find, diff, cmp, touch, mv, cp, rm, rename, ln, cd , chmod, rmdir, mkdir`

- Filters*
    -  `awk, cat, cut, grep, head, less, more, od, paste, sed, shuf, sort, split, tac, tail, tr, uniq, wc`

.footnote[
* Some filters are listed above as well.
]
- System and User Information
    - `date, domainname, du, groups, hostname, id, last, printenv, users, times, who`

- Process and Job Control
    - `bg, fg, jobs, pgrep, ps, kill, pkill, timeout, uptime, ^C, ^D, ^S, ^Q`

- Miscellaneous
    - `seq, echo, yes, man, bc`

---
# General Command Syntax
- In general, commands may have options and arguments. The general form is
   ```bash
     commandname  [options]  arguments
   ```
where square brackets [] mean that the thing enclosed in them is optional.

- Options begin with a hyphen `-`. Multiple options are usually allowed.
For most commands, if the option does not require an argument of its own, it may be
combined with other options using a single hyphen. E.g.:

   ```bash
    $ls -a -l  ~
   ```
can be written
   ```bash
    $ls -al ~
   ```
but
   ```bash
    $cut -d, -f2 names.csv
   ```
cannot be written
   ```bash
    $cut -df,2 names.csv
   ```
---

# Viewing Files
- Many of the commands to view the contents of files are simple to use. Some
are intended for text files only, others any type of file. Because they are easy,
no examples are given. Look up the syntax and options in the man pages.

- All are used by following the command name with a list of files. They include:

    - `more`  and `less`  -  display a screenful at a time of the given text files

    - `view` -  brings up the `vi` editor in read-only mode. Use it only if you
know `vi`. It can be given multiple text file names.

    - `cat` -  "__c__oncatenates __a__nd __p__rints" its list of text file arguments. It whizzes
by on the screen, so use it only to see small files.

    - `od`  - displays an "octal dump" of any file, including binaries.
It has lots of options to make it very useful.

    - `strings` - print the strings of printable characters in files.
It is very useful for finding the strings in compiled code.
---
# `ls`

- This lists information about files and directories
- Syntax:
   ```bash
    ls [option]... [file]...
   ```
If no files are given it lists information about the current directory.
- Some very useful options:
   ```bash
       -l    - produce a "long" listing
       -a    - show all files, including hidden ones
       -F    - append trailing character to classify type
       -t    - sort by time of last modification, most recent first
       -R    - recursively list subdirectories
   ```
- Examples
    - list all files in current directory with most recent first, classifying
   ```bash
    $ls -atlF
   ```
    - list all files sorted by access time
   ```bash
    $ls -atulF
   ```
---
# `basename`

- `basename` strips leading directory path and suffix from filenames

- Syntax:
   ```bash
    basename pathname [suffix]
   ```
   outputs `pathname` with the leading path removed and, if it has a suffix matching `suffix`
   with that removed also.

- Examples:
   ```bash
    basename /usr/bin/sort
              -> sort
    basename include/stdio.h .h
              -> stdio
    basename include/stdio.h .foo
              -> stdio.h   # i.e., suffix does not match
    basename ~/hunter/cs395.86_s19/blogs/stewart-weekly  -weekly
              -> stewart
   ```


---
# `dirname`

-  `dirname` strips the filename from a pathname, leaving the directory path.

- Syntax:
   ```bash
    dirname pathname [pathname] ...
   ```
   outputs each pathname with its last non-slash component and trailing slashes
       removed.


- Examples:
   ```bash
    dirname /usr/bin/sort
              -> /usr/bin
    dirname /usr/bin/gcc /usr/lib/gcc /usr/share/man/man1/gcc.1.gz
              ->
                /usr/bin
                /usr/lib
                /usr/share/man/man1
    dirname ~/hunter/cs395.86_s19/blogs/stewart-weekly
              -> /home/stewart/hunter/cs395.86_s19/blogs
   ```

---
# `find`

- Its man page states, "search for files in a directory hierarchy", but this is
an understatement. It is one of the most powerful commands available in Unix.

- The `find` command allows you to apply commands and actions to all files matching
a set of search criteria in one or more subtrees of the Unix file system.

- Simplified syntax (some options suppressed):
   ```bash
       find  [starting-point...]  [expression]
   ```

- `starting-points` are the directories to act as the roots of the hierarchies to search.
- `expression` describes what is to be searched for; it includes search criteria as
well as actions to perform.

- With no expression, `find` displays every file in the trees rooted at the `starting-points`.
The default action is `-print`

   ```bash
    find . -print
   ```
is equivalent to
   ```bash
    find .
   ```

---
#  `find`
###  finding by file name

- Finding (printing paths to) all files in the directory `dir` whose name ends in `.cpp`:
   ```bash
    find dir -name "*.cpp"
   ```
__Lesson__: The `*` is a shell wildcard that matches 0 or more characters, including the
period if it is the first character in the name.

- Finding all files in `dir` whose name is exactly `main.cpp`
   ```bash
    find dir -name "main.cpp"
   ```
--

- Finding all files in `dir` whose name ends in any of `.jpg`, `.JPG`, `.JPg`, etc:
   ```bash
    find dir -iname "*.jpg"
   ```
__Lesson__: `-iname` is a case-insensitive version of `-name`.

--

- Finding all files in `dir` whose name ends in any of `.jpg`, `.JPG`, `.jpeg`, `.JPEG`, etc:
   ```bash
    find dir -iname "*.jpg"  -o -iname "*.jpeg"
   ```
__Lesson__: Expressions return `true` or `false`.
`-iname` is a __test__ applied to each file as it is found. If the filename matches,
it returns `true` otherwise `false`.
The `-o` is a logical OR-operator; its operands above are `-iname "*.jpg"`
and  `-iname "*.jpeg"`.
If either is true then the filename passes the test.

---
# `find`
### finding by time stamp

- Unix timestamps files with three stamps: time of last access, time of last
modification, and time of last change of status (file properties).

- Finding files in `dir` that have been __modified__ within the past 3 hours:
   ```bash
    find dir -mmin -180
   ```
__Lesson__: -mmin expects an argument in minutes. The `-` in front of 180 means "less than".

--

- Finding files in `dir` that have been modified more than 3 hours ago:
   ```bash
    find dir -mmin +180
   ```
--

- Finding files in `dir` that have been __accessed__ (use `-amin`) exactly 3 hours ago:
   ```bash
    find dir -amin 180
   ```
--

- Finding files in `dir` whose __status changed__ (use `-cmin`) within the past 8 hours:
   ```bash
    find dir -cmin -480
   ```

---
# `find`
### finding by other properties

- In Unix, properties such as size, type, permissions,  user ownership, group
ownership, and more, are stored in a special structure called an __inode__. `find`
can test any of these properties.

- Finding files in `dir` larger than 500 Kilobytes (1024 bytes):
   ```bash
    find dir -size +500k
   ```

--

The letter after the number can be `c`, `w`, `k`, `M`, or `G`. Guess what they stand for.
- Finding files in `dir` that are executable:
   ```bash
    find dir -executable
   ```
--

- Finding files in `dir` that are owned by user stewart and group cs_ossd
   ```bash
    find dir -user stewart -a -group cs_ossd
   ```
__Lesson__: `-a` is the logical AND-operator

---
# `find`
### finding by other properties

- Finding files in `dir` for which people other than the owner and the group
have write access, whether or not the owner or group does.
   ```bash
    find dir -perm  -002
   ```
It is dangerous to let anyone be able to write to a file. This looks for all
such files.

- Finding files in `dir` for which the owner has read, write, execute permission
and no one else has access of any kind:
   ```bash
    find dir -perm  700
   ```
- Finding files in `dir` that are __regular__ files:
   ```bash
    find dir -type f
   ```
To find directories, replace `f` with `d`.

---
# `find`
### taking actions when files are found

- You can use add __actions__ to expressions. These actions can be applied to
the files for which the test returns true, or to a set of arguments that follow
the action.

- Useful actions include `-print`, `-prune`, and `-exec`.
There are many others.

    - `-prune` is used to prune the search, i.e., prevent it from descending the tree.
    - `-exec  <command>` executes the <command> that follows it.

- Run the `file` command on every regular file below the current directory :
   ```bash
    find . -type f -exec file '{}' \;
   ```
__Lesson__: `exec` is followed by a command. `{}` after the command is replaced
by the file that matched the test. It must be written in quotes, and the semicolon
must be escaped with backslash as shown.

- Remove every file whose names ends in `~` below the current directory (dangerous
if you make a mistake):
   ```bash
    find . -name "*~" -execdir /bin/rm '{}' \;
   ```

---

# Streams, Files, and Redirection

- A __stream__ is a flow of bytes into or out of a running process. In Unix, a stream is
implemented with a data structure that includes buffers to store the bytes and
various data members to control its flow and keep track of the status of the
stream.

- Unix provides every running process with three __standard streams__:
    - __standard input__, __standard output__, and __standard error__




<img src="img/stdinout.GIF" width="300" style="float:right;" >


- Streams can be connected to devices or files or other processes, as you will
see shortly.

- When a process is created, it is given an array that has pointers to its
open files;  pointers to these three streams occupy the first three array
entries, namely standard input is index 0, standard output 1, and standard
error 2.

- Initially, standard input is connected to the keyboard
(terminal device), and  standard output and error, the terminal device*.

.footnote[
* The terminal window is called a pseudo-terminal in Unix.
]


---
# File Descriptors and Streams

- The index values in the array of open files belonging to the process
are called __file descriptors__. The table below summarizes the different
views of the standard streams.

File<br> Descriptor | Stream | Associated Device |  C symbolic name
:---|:---|:---|:---
 0      | Standard Input | Keyboard |stdin
 1      | Standard Output | Screen or Terminal Window | stdout
 2      | Standard Error | Screen or Terminal Window |stderr


---
# Redirection
### Input Redirection

- All shells allow for  any stream to be disconnected from its
default device and reconnected to or from files,
the streams of other processes, or other devices. This is called
__I/O redirection__.

- Attaching a file to the standard input is called __input redirection__.
The `<` operator is the __input redirection operator__:

   ```bash
    command < file
   ```
Example:
   ```bash
    cat < file1
   ```
The contents of file1 are redirected to the standard  input of the `cat` command,
which is not very useful, but illustrates the idea.

---
# Redirection
### Input Redirection

The `bc` command can be used as a simple calculator. If you type `bc` on the command line,
it waits for you to enter  an arithmetic expression such as 25 + 4 or
something more complex. When you type <enter> it evaluates and prints the
expression.

6 + 4
--
<br>
10
--
<br>
12 ^ 2
--
<br>
144

--

Suppose `file1`  contains the sequence of arithmetic expressions
   ```bash
    6 + 4
    12 ^ 2
   ```
--
Run the command `bc < file1` at the command prompt:
   ```bash
    $ bc < file1
    10
    144
   ```
This shows that file1 replaced `bc`'s standard input.
---
# Redirection
### Output Redirection

- Attaching a file to the standard output is called __output redirection__.
The `>` operator is the __output redirection operator__:
   ```bash
    command > file
   ```
Example
   ```bash
    cat file1 file2 file3  > combined_file
   ```
concatenates files `file1`, `file2`, and `file3` into a new file named `combined_file`.

 If `combined_file` already existed and the `bash` variable `noclobber` is set,
 the command fails and you will see an error message such as
   ```bash
    bash: combined_file: cannot overwrite existing file
   ```
--

 To overcome this, use the `>|` operator, which will forcibly replace the existing file:

   ```bash
    cat file1 file2 file3  >| combined_file
   ```
---
# Redirection
### Error Redirection

- Attaching a file to the standard error is called __error redirection__.
The `>` operator is also used to redirect standard error, but with a slight
modification; use
   ```bash
    command 2> file
       ```
__No space__ between `2` and `>`.  `2` is the file descriptor for
the standard error stream. In general, if _n_ is a file descriptor, _n_`>` redirects
 the stream associated with it to the file.

--

- To send the errors of a command to one file and the standard output to another,
the simplest solution (there are a few ways to do this) is:
   ```bash
    command 2> error_file  > output_file
   ```
 If either file exists and `noclobber` is set, it will fail;
to overwrite them use
   ```bash
    command 2>| error_file  >| output_file
   ```

- To redirect the standard output and the standard error to the __same__ file,
use
   ```bash
    command &> file
   ```


---
# Redirection
###  Redirection Examples

- Some commands can produce many error messages. Sometimes you don't care about
the errors. If you try to display the _entire file system_ (bad idea) using `ls -R`
there will be many `permission denied` errors. The way to discard them is like
this:

   ```bash
    ls -R /  2>/dev/null  > verybigfile
   ```
__Lesson__: `/dev/null` is a black hole; any data written to it is discarded.

- We can take advantage of the fact that __the `cat` command reads from standard
input if it is not given a filename as an argument__, to create a plain text file
while taking notes, like this:
   ```bash
    $ cat > notes
    blah blah blah
    ^D (Control D to stop)
    $ cat notes
    blah blah blah
   ```
 We must type Control-D  to terminate the
`cat` command and close the new file named notes.

---
# Redirection
### Appending

- To append to a file (or to create it if it does not exist) use the
`append redirection operator` `>>`.

   ```bash
    command >> file
   ```
 which adds the output of the command to the end of the file.

- Sometimes you will find it useful to log the results of a command that you
run, or perhaps log its errors. Suppose `backup` is some backup command that you run
every day. You can do either:
   ```bash
    backup 2>> ~/.backup_errlog  >> ~/.backuplog
   ```
which sends the errors of the command to one log file and the standard output to
another.
---
# Pipes

- Attaching the standard output of one command to the standard input of another
is done by creating a __pipe__.
The `|` operator is the __pipe operator__.
    - Syntax:
       ```bash
        command1 | command2
       ```

- The real power of pipes is that they can be used with __filters__. Examples of
pipes will follow the introduction of filters.


---
# Filter Introduction

- A filter is a UNIX command whose input and output are plain text,
and that expects its input from standard input and puts its output
on standard output.

- Most filters will also read their input from one or more filenames listed
on their command-line.

- Filters are useful because their output is a transformation of their
input, in one way or another, such as by sorting it, removing words or lines
based on a pattern or on their position in the line or file.

- Filters are chained together with multiple pipes to do become the workhorses of
Unix systems.

---
# Filter Synopsis

Filter | Description
:--- |:---
`awk`  |  pattern scanning and processing language
`cat`  |  concatenate files and print on the standard output
`cut`  |  remove sections from each line of files
`fold`  |  wrap each input line to fit in specified width
`grep, egrep, fgrep`  |  print lines matching a pattern
`head`  |  output the first part of files
`less`  |  does more than `more`; see `more` below.
`more`  |  file perusal filter for crt viewing
`od`  |  dump files in octal and other formats
`paste`  |  merge lines of files
`sed`  |  stream editor for filtering and transforming text
`shuf`  |  generate random permutations
`sort`  |  sort lines of text files
`split`  |  split a file into pieces
`tac`   |  concatenate and print in reverse order
`tail`  |  output the last part of files
`tr`  |  translate or delete characters
`uniq`  |  report or omit repeated lines
`wc`  |  print newline, word, and byte counts for each file

---
# Filters: `cat` and  `tac`

- The `cat` command is a technically a filter, but without options it does
no transformation: its output is exactly its input.

- It does have some handy uses. The `-n` option numbers lines, `-b` numbers
non-blank lines, `-s` _squeezes_ blank lines, and `-v` shows non-printing characters:

   ```bash
    ls  . | cat -n
     1	bash_tutorial_01.html
     2	css/
     3	img/
     4	js/
   ```
 lists the current directory and numbers the lines.

- `tac` prints the lines in reverse order. I rarely have use for it.

   ```bash
    ls  . | cat -n | tac
     4	js/
     3	img/
     2	css/
     1	bash_tutorial_01.html
   ```
---
# Filters: `head` and `tail`
- Simply put, `head` displays the first _N_ lines of its input and `tail`, the last
_N_ lines. By default for both,  _N_ is 10. To print a different number of lines,
explicity use `-N` where _N_ is a positive integer:

   ```bash
    head -1 myfile
   ```
 displays just the first line of `myfile`, and

   ```bash
    tail -1 myfile
   ```
 displays the last line.
--

- One way to print the _nth_ line of a file is like
this:
   ```bash
    head -4 myfile | tail -1
   ```
 which prints the 4th line of `myfile`. So I can use the following pipeline to
get the summary of any command from the man page for it:

   ```bash
    man awk | head -4 | tail -1
   ```
 since the summary is always line 4.
---
# Filters: `sort`
- `sort` is one of the most useful and easy to use filters:

   ```bash
    sort myfile
   ```
 will sort the text file named `myfile` and print it on standard output.

--

- But its exact behavior varies from one system to another; there are many
different implementations of `sort`.

--

- By default it uses the current `locale` settings
(the _collating order_ set in your environment*).
The major difference in English is whether uppercase precedes lowercase
or whether case is ignored.

- Locales are a subject way ahead of us. Suffice it to say that locale
environment variables control how information is displayed in the
terminal, such as the language and character set, numbers, dates, times, and more.

.footnote[
* The collating order is the order of the characters in the
character code of the terminal, which is usually ASCII or UTF-8.
]

---
# Filters: `sort` Examples

- Assume `myfile` contains the lines
   ```bash
     a
     b
     A
     B
   ```
 Forcing the locale to be U.S. English and running `sort`:
   ```bash
    LC_COLLATE="en_US.UTF-8"  sort myfile
    a
    A
    b
    B
   ```
 Forcing the locale to be the "C" locale  and running `sort`:
   ```bash
    LC_COLLATE=C  sort myfile
    A
    B
    a
    b
   ```
---
# Filters: `sort` Examples

- To force `sort` to ignore case and fold upper and lower case together, using
GNU's `sort`, the option is `-f`:
   ```bash
    LC_COLLATE=C  -f sort myfile
    a
    A
    b
    B
   ```

- `sort` by default will treat numbers like strings. For example, it will sort
1, 2, 10, 20 in this order:  1, 10, 2, 20.

- To tell `sort` to sort __numerically__, use `-n`.

- To tell `sort` to __reverse__ its order, use `-r`.

- To tell `sort` to delete duplicate lines on output, use `-u`.

- `sort` can sort by __fields__ in a line. The GNU version uses the `-k` option
to specify the specific _key_ position (1-based). The `-t` option tells `sort`
what character keys in the line. By default `sort` uses whitespace. If a file
has colon-separated fields, and you want to sort numerically by field 2, use
   ```bash
      sort -t':' -k2 -n   myfile
   ```
---
# Filters: `uniq` 

- `uniq` filters out matching adjacent lines from its input stream, sending
unique lines to output.  If the input stream is sorted and has duplicates, this
produces output with duplicates removed:
```bash
 sort mydata | uniq
```
 produces a stream of unique lines from the file `mydata`.

- It has several useful options as well:
   ```bash
       -i    - ignore case when trying to match
       -c    - prefix lines by the number of occurrences
       -d    - only print duplicate lines, one for each group
       -u    - only print the duplicate lines

   ```
   
---
# Combining Filters 

- Putting some of this filters together, 
NYC Open Data has a database of baby names whose lines look like this:
```bash
2011,FEMALE,HISPANIC,Geraldine,13,75
2011,FEMALE,HISPANIC,GIA,21,67
2011,FEMALE,HISPANIC,GIANNA,49,42
...
```
- Many names are repeated. We can get the frequencies of each name using
this pipeline, assuming the file is named `babynames.csv`:
```bash
 sort -k4 babynames.csv | cut -d, -f4 | uniq -ic
```
 where `sort` sorts using the 4th field, after which `cut` prints only the 4th field, then
 `uniq` filters out duplicates and puts counts to the left of the names, ignoring 
 case.
 
 We can get the ten most frequent names like this:
```bash
 sort -k4 babynames.csv | cut -d, -f4 | uniq -ic | sort -k1 -nr | head -10
```


---

# Filters: `grep`, `egrep`, and `fgrep`

- These commmands are the most powerful of all.
`grep` and `egrep` are given a pattern, called a __regular expression__, and
use this to filter lines that match the pattern.
`fgrep` is a _fast_, fixed-string version that does not use patterns.

- Regular expressions are complex;  mastering them is worth the effort because
they are used by `vi`, `sed`, `ed`, `awk`, `grep`, and `egrep`.

- Some  examples to start:
   ```bash
    grep '\<cout\>'  prog.cpp
   ```
--
 prints all lines containing the exact word `cout` in file `prog.cpp`.

--
   ```bash
    grep -c '^ *$' prog.cpp
   ```
--
 prints a count of the number of lines in `prog.cpp` that contain only blanks or
no characters at all.

--
   ```bash
    grep  '\/\*.*\*\/' prog.cpp
   ```
--
 prints all lines in `prog.cpp` that have C-style comments `/* ... */`.

__Lesson__: Enclose the pattern in single quotes  to
 prevent the shell from interfering.

---
# Regular Expression Rules
- In the rules that follow, `\0` denotes an empty string.
- The complete set of rules can be found in the __regex__ man page in
section 7, which defines the POSIX-compliant regular expressions.

- Any sequence of characters matches itself: __abc__ matches the string "abc".


- A regular expression followed by \* matches the concatenation of 0 or more
strings each of which is matched by the regular expression. \* is called the
__closure__ operator.
    -  __`a*`__ matches 0 or more `a`'s:
       - `\0`, `a`, `aa`, `aaa`, ...

    -  __`ab*`__ matches `a` followed by 0 or more `b`'s:
       -  `a`, `ab`, `abb`, `abbb`, ...

    -  __`ab*ac*`__ matches `a` followed by 0 or more `b`'s followed by `a` followed
 by 0 or more `c`'s:
       -  `aa`, `aba`, `aac`, `abba`, `abac`, `aacc`, `abbba`, `abbac`, ...


---
# Regular Expression Rules

- Use __`\( \)`__  to group for applying \* to more than one character:
    - __`\(ab\)*`__ matches 0 or more `ab`'s:
        - `\0`, `ab`, `abab`, `ababab`, ...

- If you use __extended regular expressions__ either by writing  `grep -E`
or by using  `egrep` instead, you can use `+`, the __positive closure__ operator.
It matches __1 or more__ strings each of which is matched by the preceding
regular expression. You can also use ordinary parentheses for grouping:
   ```bash
      egrep '(ab)+' myfile
      grep -E  '(ab)+' myfile
   ```
 both match all lines in `myfile` that have 1 or more consecutive `ab` substrings.

- Warning:
   ```bash
      grep '(ab)*' myfile
   ```
 only matches `\0`, `(ab)`, `(ab)(ab)`, ...
because `grep` was used instead of `egrep`.

---
# Regular Expression Rules
### Character Classes

- The period __`.`__ matches any single character.


 ` ` | ` `
:--- |:---
__`[list-of-characters]`__ | matches any single character in the list.
__`[a6j&]`__       | matches a, 6, j, or &
__`[0-9]`__        |  matches any single digit
__`[a-zA-Z0-9]`__  |  matches any letter or digit
__`[]]`__      |  matches right square bracket `]`
__`[0-9-]`__    |matches any single digit or hyphen
__`[-0-9]`__     | matches any single digit or hyphen
__`[_a-zA-Z0-9]`__ | matches any letter, digit or underscore.


- __`\w`__ is a shorthand for __`[_a-zA-Z0-9]`__. These characters are called
__word characters__.

- The `^` inside brackets means the complement:


 ` ` | ` `
:--- |:---
__`[^a6j&]`__  | matches anything except a, 6, j, and  &
__`[^0-9]`__   | matches anything except a digit.


---
# Regular Expression Rules
### Character Classes

- You can combine character classes with the * operator to create useful patterns:


 ` ` | ` `
:--- |:---
__`\(c[acgt]g\)*`__ | matches 0 or more sequences of `cag`, `ccg`, `cgg`,or `ctg`
__`[1-9][0-9]*`__   | matches any decimal numeral except 0
__`[A-Z][a-z]*`__   | matches words that start with an uppercase letter.
__`[a-zA-Z_][_a-zA-Z0-9]*`__   | matches C/C++ identifiers.

__`\(...\)*`__      | matches any string whose length is a multiple of 3.


---
# Regular Expression Rules
### Anchors

- The caret __`^`__ anchors a regex to the beginning of a line,
and the dollar sign, __`$`__, anchors it to the end of the line.

- __`\<`__ anchors a regex to the start of a word. This means that  the character
before it must be a non-word character.

- __`/>`__ anchors the regex to the
end of a word. This means that the character after it is a non-word character.


 ` ` | ` `
:--- |:---
__`^drwx`__   | matches lines whose first 4 characters are drwx
__`^\w`__     | matches lines that begins with a letter or digit or underscore
__`abcd$`__   | matches lines whose last 4 characters are abcd
__`^abc$`__   | matches lines that contain only abc
__`^$`__      | matches empty lines
__`^[ ]*$`__  | matches empty lines or lines containing only spaces
__`\<fred`__ | matches any word starting with `fred` but not words like `alfred`
__`fred\>`__ | matches any word ending with `fred` but not words like `freddy`
__`\<fred\>`__ | matches exactly  `fred` surrounding by non-word characters

---
# Regular Expression Rules
### Backreferences

- When you enclose a basic regular expression in __`\( \)`__ brackets, or an extended
regular expression in ordinary parentheses __`( )`__,
the string that matched it is "remembered" for future use.

- The regular expression __backreference__, __`\1`__, matches the first such
"remembered string." In

      __`\(aa*\)b\1`__

      any string that matches `aa*` is saved into a storage cell named \1.
 The only strings that this expression matches are
 `aba`, `aabaa`, `aaabaaa`, `aaaabaaaa`, ...,.

- In general, the expressions `\1`, `\2`, `\3`, …, `\9` remember matches of the
1st, 2nd, 3rd, up to 9th parenthesized regular expressions.

- The expression

    __`^\(.*\):\(.*\)::\1:\2$`__

    matches lines of the form
       `x:y::x:y`     where `x` and `y` are possible empty strings, such as

    abc:666::abc:666

---
# Filters: `cut` and `paste`
### `cut`

- Both  `cut` and `paste` are handy. `cut` can be used to cut lines in specific
places, whether at character positions, or by field positions, and can output
the cut pieces with different output delimiters. You can specify what delimits
the fields.

- The default field separator is the TAB character.

- You can use `cut` on csv files to pick out columns:

- Examples
   ```bash
    cut -f1,5 -d: /etc/passwd
   ```
 prints the first and fifth fields of the `/etc/password` file, i.e., the username and "gcos"
field.
   ```bash
    cut –c1-10  myfile
   ```
 prints only the first 10 characters of each line of `myfile`.


---
# Filters: `cut` and `paste`
### `paste`

- `paste` combines lines  consisting  of  the sequentially corresponding 
lines from different files, separated by TABs, to standard output.

- Example:
Suppose that there are two files named `cities` and `countries` whose contents
are as shown below (in two columns to save space.)
.left-column2[
```bash
$ cat cities
Rome
Paris
London
Dublin
Tokyo
```
]
.right-column2[
```bash
$ cat countries
Italy
France
England
Ireland
Japan
```
]
.below-column2[
Then the `paste` command will "merge" the files onto standard output,
separating the words with tabs:
```bash
$ paste cities countries
Rome    Italy
Paris   France
London  England
Dublin  Ireland
Tokyo   Japan
```
]
---
# Filters: `cut` and `paste`
### `paste`

- We can feed standard input into the `paste` command simultaneously. A
hyphen '-' represents standard input when it is used in place of a filename
argument, as in 
  ```bash
    paste file -
  ```

 We can use this idea to add numbers to the lines in our previous example, 
 e.g. line 1, 2,3, 4, and 5, as follows:
```bash
$seq 1 5 | paste -  cities countries
1	Rome    Italy
2	Paris   France
3	London  England
4	Dublin  Ireland
5	Tokyo   Japan
``` 
- See what happens when you try 
```bash
$seq 1 30 | paste -  - -
```
 Pretty interesting?

---


# A Bit About bash

- bash was written by Brian Fox in 1989 at the request of Richard Stallman,
of the Free Software Foundation. It was added to by Chet Ramey in the early 1990's.

- At the time, there were several other shells, such as the __C-shell__ (`csh`)
written by Bill Joy,
and the __Bourne shell__ (`sh`), written by Stephen Bourne).


- bash was a replacement for the [Bourne shell](https://en.wikipedia.org/wiki/Bourne_shell)
Its name is a pun:

  - bash = __b__ourne __a__gain __sh__ell


- It is distributed with most Linux distributions ans is the default shell in
many systems, including most Linux distributions, Apple's macOS, and Solaris.

- It has become very popular.

---




# Shell Scripts

- All common Unix shells are Turing-complete* __scripting__ languages.
Programs written in a shell's language are called __shell scripts__.



.footnote[
* A language is Turing complete if it can be used to simulate any Turing machine.
]


- A _shell script_ is basically a program written in the shell programming language.

- A bash script is written in bash; a C shell script is written using the syntax of the
C shell.

- This is a simple bash script:

   ```bash
    #!/bin/bash
    # This script does nothing except print "Hello world; code responsibly!"
    # Its purpose is to show what the first line looks like and
    # to introduce comments.
    #
    # Written by Stewart Weiss, Sept. 16, 2014

    echo "Hello world; code responsibly!"
   ```

- The first line is required - it tells the shell to run the interpreter
 `/bin/bash` using the rest of the file as its input.  In effect it  says,
"I am a bash script". You must put it at the top of every bash script.

- The comment delimiter is the `#` - anything after it is ignored by bash.

- The only command in this file is the `echo` command.



---

# Running a Shell Script

- Suppose the preceding script is in a file named `helloworld` in the current
working directory. We need to make it an executable file by typing
at the prompt (here assumed to be `$`):

   ```bash
   $ chmod +x helloworld
   ```

- The `chmod` command changes the permissions on its file arguments. The `+x`
means "add execute permission for all users". The file also needs to be
readable, so it is better to write, instead,

   ```bash
   $ chmod +rx helloworld
   ```

- We can run the script by typing its name, and the output appears below.
   ```bash
   $ ./helloworld
   Hello world; code responsibly!
   ```




---






    </textarea>

<!-- these scripts are used for redering the above as markdown -->
     <script src="js/remark.js" type="text/javascript">
    </script>
    <script src="js/remark_conf.js" type="text/javascript">
    </script>

<!-- the following scripts allow Latex-like formatting -->
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({
         extensions: ["tex2jax.js"],
         jax: ["input/TeX", "output/HTML-CSS"],
         tex2jax: {
           inlineMath: [ ['$','$'], ["\\(","\\)"] ],
           displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
           processEscapes: true
         },
         "HTML-CSS": { availableFonts: ["TeX"] }
       });
    </script>


  </body>
</html>
